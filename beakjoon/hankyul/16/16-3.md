## [Week 2 Offline Meeting] Baekjoon 16-3

이 문제는 석운님의 도움으로 풀 수 있었습니다.(고마워요 석운님ㅠㅜㅠㅜ)

# 1. 문제 설명 및 해설

문제는 간단합니다. 00, 1 두 종류의 타일을 가지고 길이가 N인 수열을 만들때 만들 수 있는 수열의 갯수는 몇인가? 입니다. 저는 이 문제를 중복 조합 - > 조합의 합으로 해결 했습니다. 예를 들어 길이가 5인 수열을 만들때 00, 1의 개수를 표로 만들면 다음과 같습니다.

|00의 개수|1의 개수|중복조합 -> 조합|
|------|---|---|
|0|5|`1_H_5 -> 5_C_5`|
|1|3|`2_H_3 -> 4_C_3`|
|2|1|`3_H_1 -> 3_C_1`|

따라서 N이 주어질때 아웃풋은 조합의 합인 `Sigma(N-i_C_N_2*i)`입니다.(너무 보기 어렵네요...) 어쨌든, 여기까지 풀고 저는 거의 8시간을 허비했습니다. 왜냐하면 저 조합의 합을 구하는게 앵간치 어려운게 아니기 때문입니다. 그래서 거의 자포자기 하고 오프라인 모임을 가서 팀원들과 같이 풀었는데 석운님이 딱!하고 풀어주셨습니다. 이제 다시 설명을 진행하겠습니다.

위에서 만든 식으로 N의 값을 1~8정도로해서 아웃풋을 구해보면 피보나치 수열임을 알 수 있습니다.(왜 나는 몰랐지?) 하지만 왜 이게 피보나치 수열을 이루는지는 [이 블로그](https://m.blog.naver.com/PostView.nhn?blogId=mondvopel&logNo=220020338579&proxyReferer=https:%2F%2Fwww.google.com%2F)를 참고 하시길 바랍니다.

|N|output(fibonacci)|
|--|---|
|1|`f_1 = 1`|
|2|`f_2 = 2`|
|3|`f_3 = 3`|
|4|`f_4 = 5`|

# 2. 코드 설명
그냥 기본 피보나치 수열에서 DP(dynamic programming)을 조금 가미한게 전부 입니다. `f_n = f_n-1 + f_n-2`이라는 점화식을 recursive하게 표현했고 한번 찾은 값은 다시 계산하지 않도록 배열에 저장했습니다. 시간 복잡도는 `O(N)`정도 인거 같습니다.


```c
int fibo(int n, int * arr, int* index){
  if(n==0 || n == 1){
    arr[n] = n%15746;
    return arr[n];
  }
  if (n <= *index){
    return arr[n];
  } else{
    arr[n-2] = fibo(n-2, arr, index);
    if(*index < n-2) *index = n-2;
    arr[n-1] = fibo(n-1, arr, index);
    if(*index < n-1) *index = n-1;
    arr[n] = (arr[n-1] + arr[n-2])%15746;
    if(*index < n) *index = n;
    return arr[n];
  }
}
```

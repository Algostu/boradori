
# 06.06일 날 2번째로 풀었던 문제 - 히스토그램에서 가장 큰 직사각형

## 문제 설명

문제 출처 :  [백준 히스토그램에서 가장 큰 직사각형](https://www.acmicpc.net/problem/6549)

이 문제는 히스토그램에서 가장 넓이가 큰 직사각형을 구하는 문제이다.

1. 스택을 이용하여 현재 추가할 직사각형의 높이가 높으면 계속 진행하고, 그렇지 않으면 현재 추가할 직사각형의 높이보다 스택의 top()이 낮을 때 까지 pop()하면서 사이에 존재하는 직사각형의 넓이를 구한다.

2. 넓이를 계산할 때 현재 높이는 스택의 top()이고, 밑변은 pop() 후, top()번째  직사각형 까지이다.

마지막에 도달하면 스택이 빌때까지 pop을 진행하여 넓이를 구한다.
```c++
	for(int i = 1; i <= n+1; i++) 
	{
		while (!box.empty() && arr[box.top()] > arr[i]) 
		{
			long long boxIndex = box.top();

			box.pop();

			long long x = i - 1 - box.top();

			ans = std::max(ans, x * arr[boxIndex]);

		}
		box.push(i);
	}

	std::cout<<ans<<'\n';
```
## 전체 코드
```c++
#include <iostream>
#include <stack>

int main()
{
	while(1)
	{
		int n;
		std::cin >> n;
		
		std::stack<long long> box;
		long long arr[100001] = {0, };
		long long answer = 0;

		if(n == 0)
			break;

		for(int i = 1; i <= n; i++)
			std::cin >> arr[i];

		box.push(0);

		for(int i = 1; i <= n + 1; i++)
		{
			while(!box.empty() && arr[box.top()] > arr[i])
			{
				long long boxIndex = box.top();
				box.pop();

				long long x = i - 1 - box.top();

				answer = std::max(answer, x * arr[boxIndex]);
			}
			box.push(i);
		}
		std::cout << answer << '\n';
	}

	return 0;
}
```


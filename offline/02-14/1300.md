## K번째 수 (백준 1300번)

이 문제는 전에서 부터 진짜 진짜 풀고 싶었지만 풀지 못했던 문제이다. 왜 인지는 몰라도 이번에 이분 탐색 문제가 전부 기록이 날아가서 다시 풀고 있는데 이번에 한 2시간 30분안에 푼거 같아서 뿌듯하다. 걸린 시간 보다 이 문제를 풀었다는 것이 진짜 뿌듯하다!!!

## 이분탐색을 이용한 풀이
이문제의 핵심은 어떤 수의 순서를 `O(N)` 시간안에 구할 수 있다는 점이다. 이점을 활용해서 문제를 해결할 실마리를 잡았다. 나도 어떻게 이 생각을 해냈는지 모르겠다. 그냥 여러가지 경우의 수를 생각해보다가 한것 같다.

```
while(true){
        long long c = (left + right) / 2;
        long long start = order(n, c);
        long long end = order(n, c+1);
        if(start < k and k <= end){
            k -= start;
            N = c;
            break;
        } else if(end <= k){
            left = c + 1;
        } else {
		right = c - 1;
	}
}
```
  
N^2 수부터 (N+1)^2 수 사이에 K가 포함되어 있다면 그 사이에 있는 수는 직접 정렬해서 순서를 구했다. 뭔가 무모한 방법인거 같다. 다른 사람이 어떻게 풀었는지 확인해봐야겠다. 이 방법이 성공한 이유는 2*N개 이하로 수가 있음이 보장되어 있기 때문이고 정렬하는데 걸리는 시간 복잡도는 따라서 `O(NlogN)`이다. 

```

for(int i=1; i<=n; i++){
        int start = ceil(N*N / i);
        int end= (N+1)*(N+1);
        start = start > n ? n+1 : start;
        for(;start*i<end && start<=n; start++){
            arr.push_back(start*i);
        }    
 }
```

## 실수
이 문제 또한 실수를 했다. 두가지 실수를 했는데 경계값 오류와 잘못된 자료형 선택이다. 경계값 오류는 내가 계산을 잘못해서 발생한 실수이다. 처음에 생각하는 것이 귀찮아서 그냥 대충하지 뭐~ 이런 식으로 생각해서 저지른 실수이다. 
두번째 실수는 자료형 선택의 실수이다. 나는 N의 자료형이 float이면 충분할 줄 알았다. 하지만 그렇지 않았다. 자료형을 double자료형으로 선택하니 ‘틀렸습니다’가 ‘맞았습니다’로 바뀌는 기적을 볼 수 있었다. 

## 다른 사람 풀이 보고 배운점
일단 난 ㅂㅅ이다. 난 ㅂㅅ이다. 난 배울게 아직도 산더미다. 난 처음에 다른 사람 코드를 보고 다른 문제 풀이인줄 알았다. 내가 이분탐색을 오해하고 있어도 한참 오해하고 있었다. 나는 답이 여러개 있어도 하나를 선택해주는줄은 몰랐다. 여기서 그걸 배웠다. 이분탐색은 모든 범위를 탐색해주며 내가 푼 문제 특성은 가장 작은 값이 답인데 이분탐색을 통해서 그걸 해결 할 수 있다. 

```

#include <bits/stdc++.h>

using namespace std;

int main(void){
  long long n, k;
  cin >> n >> k;
  long long l = 1;
  long long r = k;
  long long ans = 1;
  while(l<=r){
    long long c = 0;
    long long m = (l+r)/2;
    for(int i=1; i<=n; i++) c += min(n, m/i);
    if(c < k) l = m+1;
    else {
      ans = m;
      r = m-1;
    }
  }
  cout << ans << "\n";
}

```
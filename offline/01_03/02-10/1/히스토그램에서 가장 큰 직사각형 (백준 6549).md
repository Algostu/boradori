## 히스토그램에서 가장 큰 직사각형 (백준 6549)

이 문제는 대략 8개월만에 풀었다. 오늘은 2시간 30분정도 걸려서 푼것 같다. 막상 풀고 나니 내가 했던 실수들이 정말로 뭐였는지 왜 그렇게 실수를 했는지 원인을 마구마구 찾고 싶다. 그래서 오늘 시간을 더 할애하여 내가 틀렸던 이유에 대해서 자세히 정리하고자 했다.



## Stack을 이용한 풀이

나는 스택을 이용해서 문제를 풀었다. 문제를 풀고나서 다른 사람의 풀이를 보니 다른 사람들은 세그먼트 트리를 이용해서 푸는것 같다. 다른 사람의 코드를 보는 습관을 들이면 좋은 것 같다. 특히 실력자들이 내 놓는 풀이는 정말로 정답지처럼 깔끔하고 공부에 많은 도움이 된다. 우선 내가 생각했던 풀이를 적겠다.



나는 문제를 직관적으로 접근했다. 내가 문제를 보고 손으로 푼다면 어떻게 풀지를 먼저 생각해서 그 풀이법을 찾았다. 내가 생각한 풀이방법은 내가 선택한 도형을 가장 왼쪽으로 해서 직사각형을 그릴경우 어떤 직사각형이 그려질지를 먼저 생각했다. 이렇게 생각하니 그저께 풀었던 스택 문제가 도움이 되었다. Right First Larger Number를 찾는 문제였는데 이 문제도 직관적으로 스택을 이용해서 푸는데 애를 많이 먹었는데 이번 문제를 푸는데 도움을 받았다. 그래서 이 알고리즘은 다음과 같은 로직을 따른다.

```c++
st.push(0); 
for(llu i = 1; i<n; i++){
    while(!st.empty() and height[st.top()] > height[i]){
        llu local_max_val = height[st.top()] * (i - st.top()); 
        left_to_right[st.top()] = local_max_val;
        st.pop();
    }
    st.push(i);
}
```

스택에 height array의 index를 push하고 stack의 top element의 height 보다 작은 것이 온다면 pop 하면서 해당 인덱스의 도형을 가장왼쪽으로 삼았을 때의 직사각형의 최대 넓이를 계산한다. 로직 자체는 간단했으나 실수가 많았다.



## 지금 봐도 아리까리한 실수모음

1. input의 범위 착각 : 인풋이 항상 0보다 큰 정수가 온다고 착각했었다. 그래서 최대 넓이는 인풋의 길이보다는 크겠지라는 생각으로 처음에 주는 인풋의 길이 값을 최대 값을 저장하는 변수의 초기값으로 설정했다. 이것은 인풋에 0이 안온다면 문제가 없지만 오게된다면 당현이 틀린 알고리즘이 된다.
2. unsigned int를 index로 사용시 음수의 값 표현 안됨 : 이건 디버거가 아니면 찾아 낼 수 없었던 오류인거 같다. 누가 이걸 생각할까...진짜 하지 말아야하는 실수이고 코드 짤 때 귀찮더라고 꼭 눈 디버거를 사용해서 loop 을 돌려야하는 가장 큰 이유인거 같다. 
3. 왼쪽만 생각하는 실수 : 나는 도형의 최대 크기가 항상 왼쪽을 기준으로 삶았을 때만 있는줄 알았다. 하지만 이건 내 착각이였더. 오른쪽을 기준으로도 한번더 생각해주어야 문제를 해결할 수 있다. 이걸 생각못하고 있었던 것도 대단하고 다시 찾아서 생각한것도 대단하다.



## Segment Tree를 이용한 풀이

우선 Segment Tree를 간단하게 설명하자면 각 구간에 대해서 미리 Sum이나 Min Index등을 저장한 Tree를 말한다. 이 트리를 searching하는 방식도 특이하다. 나는 이에 대해서 잘 몰라서 우선 RedBlack Tree에서 구간 Search 함수를 공부하려고 했다. 하지만 단순히 이 구간 search만 공부하기에는 내 머리가 뭔가 부족한것 같아서 포기했다. 그래도 RedBlack Tree의 변형에 대해서 알고 있으면 나쁘지 않을 것 같아서 적어본다. 그리고 Segment Tree는 인터넷에 누군가가 공부해서 올려 놓은 것을 참고해서 풀었다.



1. 풀이

전체적인 문제를 푸는 아이디어는 다음과 같다. 우선 각 구간에서 최소 높이를 가지는 막대의 index를 구할 수 있다고 가정 한다. 이렇게 되면 문제는 쉽게 해결 할 수 있다. 먼저 전체 구간에서 최소 높이를 가지는 막대의 높이를 가지고 넓이를 구한다. 최소 높이를 가지는 막대를 한번 사용했으니 이제 다음 가지를 구해야 한다. 두가지 경우로 나눌 수 있다. 최소 높이를 가지는 막대의 왼쪽에서 더 큰 직사각형을 구할 수 있는 경우와 오른쪽에서 더 큰 직사각형을 구할 수 있는 경우이다. 왜 그 사이를 포함하는 범위는 안될까? 왜냐하면 그 사이 범위에는 최소 높이를 가지는 막대가 포함되게 되고 그렇게 되면 최대 넓이는 원래 기존의 넓이보다 무조건 작아지기 때문이다. 

그렇다면 왜 알고리즘이 빠른 것일까? 내 생각에 이 알고리즘은 Input의 개수를 N이라 하면 `O(NlogN)`정도의 속도가 나온다. 왜냐하면 최대 넓이를 구하는 구간을 나눴기 때문에 한번 이상 검색되는 구간이 없기에 N 번의 탐색 비용이 소요되고 각 탐색시 마다 각 구간의 최소 높이를 가진 막대의 위치를 알아야 하기 때문에 `logN`의 탐색 비용이 소요된다. 



2. **(Segment Tree)**앞에서 최소 높이를 가지는 막대의 Index를 구할 수 있다고 가정 하자고 했다. 이 Index는 어떻게 구할 수 있는것일까? 이 부분은 Segment Tree를 구현해서 해결 할 수 있다. 세그먼트 트리란 구간의 Sum, Avg, Min, Max와 같은 연산을 하기 위해서 기존의 자료구조를 바탕으로 새로 만든 트리를 말한다. 이 트리의 특징은 배열로 구현할 수 있다는 점과 왼쪽과 오른쪽으로 나눠서 즉, 디바이드-앤-콘쿼 알고리즘을 사용하기에 `O(NlogN)`정도의 시간으로 생성하고 `O(logN)`으로 구간 쿼리, 값 변경등을 진행할 수 있다. 생각만 해도 멋진 아이디어이다. 하지만 배우기에는 뭔가 어려워 보인다. 하지만 실제로는 전혀 그렇지 않다. 그냥 조금 생소할 뿐이다. 자세한 것은 백준에서 설명해주는 [Segment Tree](https://www.acmicpc.net/blog/view/12)를 참고하자. 진짜 잘 설명해 놓으셨다. 자 이제 시작이다.

세그먼트 트리는 크게 3가지로 나뉜다. 생성, 구간 합, 업데이트. 각각의 시간복잡도는 `O(NlogN), O(logN), O(logN)` 이다. 생성하는것은 신기하게 배열을 사용해서 생성한다. 물론 트리를 이용해서 할 수도 있다. 하지만 내가 배운 백준에서는 배열을 이용해서 간단하게 구현하려고 하는것 같다. 배열을 이용하는경우 왼쪽, 오른쪽 자식 노드로 이동은 배열의 인덱스를 이용해서 할 수 있다. 배열의 인덱스 1이 가르키는 것이 루트 노드의 인덱스라면 `1*2 = 왼쪽자식의 인덱스 번호, 1*2+1 = 오른쪽 자식의 인덱스 번호`이다. 참 간편하지 않은가? 따로 자료구조를 만들지 않아도 배열로 이동할 수 있다니, 나만 그런가? 

그리고 또다른 특이한 점은 구간을 양쪽에서 닫힌구간을 사용하면서 무조건 절반으로 나눈다. 무슨말이냐면 길이가 10인 배열의 세그먼트 트리를 구한다고 하면 인덱스는 0~9가 될꺼잔나? 그럼 루트노드에 저장되는 구간은 [0, 9] 로 표현하는 거지 보통 [0, 10)이 우리 컴공의 기본 생각이라면 여기서는 먹히지 않는다. 그리고 루트 노드의 자식 노드의 구간은 [0, 4], [5, 9] 로 나눌 수 있다. 여기서 나누는 방식은 그냥 백준님이 가르쳐 주신대로 나눴어. 다 배우고 생각해보니깐 꼭 이렇게 나눠야 하는건 아닌거 같다.

이제 생성을 해볼까? 생성을 할때 기본 알고리즘은 왼쪽 자식과 오른쪽 자식의 섬 = 나의 값 이라는 원리지. 그냥 단순한 디바이드-앤-콘쿼 적인 사고야. 

```c++
lld makeSegmentTree(vector<lld> &source, vector<lld> &segment_tree, int node_number, int start, int end){
    // In this function, we use vector as tree structure. We can structure like this by using special node_number stratigy
    // Node X.node_number*2 == X.left.node_number
    // Node X.node_number*2 + 1 = X.right.node_number
    if (start == end){
        return segment_tree[node_number] = source[start]; // or end
    }

    int mid = (start + end) / 2;

    return segment_tree[node_number] = makeSegmentTree(source, segment_tree, node_number * 2, start, mid) + 
                                        makeSegmentTree(source, segment_tree, node_number * 2 + 1, mid+1, end);
}
```



구간 합, 업데이트의 자세한 코드는 다루지 않고 기본 원리만 다룰께. 구간 합과 업데이트 메소드를 이해하기 위해서는 두개의 구간 사이의 관계를 자세히 알아야 됨. 즉, A([a, b]) vs B([c, d]) 두개의 구간이 있을 때 두 개 구간이 어떤 관계를 가질 수 있는지 이해하는 게 핵심이다. 관계는 다음과 같은 총 5가지로 나눌 수 있다.

1. 두개의 구간이 겹치지 않는가?
   1. 겹치지 않는다면 A가 B의 오른쪽에 있는가?
   2. 겹치지 않는다면 A가 B의 왼쪼겡 있는가?
2. 두개의 구간이 겹친다면?
   1. A가 B를 포함하는가?
   2. B가 A를 포함하는가?
   3. A와 B는 서로 포함하지도 않은 상태로 겹쳐 이쓴가?

구간 합을 구할 때는 두개의 구간이 겹쳐있는 경우에 뭔가를 하는 거야 만약 구하고자 하는 구간안에 노드의 범위가 포함되면 그대로 Return! 아닐 경우 다시 구간쿼리 하는거지. 업데이트는 더 간단해. 두개의 구간이 겹친다? 업데이트! 이런 식이야 ㅋㅋㅋㅋ

이 부분은 전부터 진짜 궁금했던건데 오늘에서야 배웠네. 이걸 이용해서 6549를 푼다면 진짜 오늘 하루는 성공이다! 2021-02-10 오후 7:18 유종빈 교수님 랩실에서 혼자 컵라면 먹으면서 20분동안 썼다!



이문제를 풀면서 배운것이 또 있다.

1. 쓸 데 없는 반환형은 코드를 느리게 한다.
2. 큰 배열의 경우 꼭 참조자를 붙여주자! 그리고 변경되면 안되는 경우 const를 붙여주고
3. 쓸 데 없이 큰 자료형을 사용할때는 꼭 메모리 누수를 조심하자!



## 남의 코드 보면서 배운거

1. cin.tie(NULL); : cin이 cout의 버퍼가 비워지는거랑 상관없이 사용될 수 있다. 이건 굉장히 위험하다고 판단되서 사용하지 않는다.
2. iostream::sync_with_stdio(false); : c++/c in/output의 sync를 하지 않는다. 즉, cin/scanf를 동시에 뜨면 안된다는 뜻. 자세히는 모른다. 하지만 위와 마찬가지의 이유로 사용하지 않는다. ㅂ2ㅂ2


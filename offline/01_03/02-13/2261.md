## 두 점 사이의 최소 거리 ( 백준 2261번 문제 )

- 이 문제는 푸는데 8시간 이상 걸렸다. 사실 8시간 보다 훨씬 더걸렸다. 풀이를 생각하는데에만 2시간 이상 걸렸으며 내가 짠 코드의 디버깅을 하는데에만 6시간이 걸렸다. 
- 결국 왜 이 정답이 맞는지 해결하지 못해서 정답을 보고 내가 생각한 정답이 맞다는 것을 이해했다. 그리고 이 문제의 핵심인 겹치는 부분에서 최소 거리를 구하는 건 철저히 답지를 보고 이해했다. 

## 핵심 아이디어
1. 겹치는 부분에서 최소 거리 구하기: 

겹치는 부분에서 최소 거리를 구하기 위해서는 나는 방법이 없다고 생각했다. 하지만 이는 그렇지 않았다. 나는 한가지 사실을 간과하고 있었다. 바로 겹치는 공간에서 각 점의 최소 거리는 왼쪽, 오른쪽에서 분할한 공간에서 구한 최소거리 보다 반드시 크다는 점이였다. 이를 이용해서 y정렬한 좌표들을 하나씩 비교해가면서 최소 거리보다 크다면 그 점에서의 비교는 더 이상 하지 않고 뛰어 넘는 식으로 계산했다.

 
```
int findCenterMinDist(vector<pair<int, int>> &P, int *X, int start, int end, int min_val){
    if(start > end) return 1000000000;
    if(end > 10000) end = 10000;
    sort(&P[X[start-1]], &P[X[end]], cmp);
    for(int i=X[start-1]; i<X[end]-1; i++){
        int j=i;
        while(dist(P[j], P[j+1]) < min_val){
            min_val = dist(P[j], P[j+1]);
            if(j==X[end]-2)break;
            j++;
        }
    }
    sort(&P[X[start-1]], &P[X[end]]);
    return min_val;
}
```

## 디버깅 전략

1. 눈 디버깅 보다 좋은건 없다 (with Assert) 

디버깅을 여러가지 출력을 통해서 해도 좋으나 가장 좋은 것은 내가 짠 로직을 귀찮더라도 다시한번 복기 해보는 것이 가장 좋다. 사실 처음 코드를 짤때 제대로 짠다면 이런 일은 하지 않아도 되지만 처음 코드를 짤때는 이런 점들을 신경쓰기 보다는 일단 구현 부터 해 놓자 라는 생각을 가지고 제대로 하기 쉽지 않다. 따라서 이를 해결하기 위해서는 assert함수와 같이 내가 생각한 대로 프로그램이 동작하는지 확인해봐야 한다.

2. 여러가지 테스트 케이스 돌리기

최대값, 최소값, 가장 간단한 모습부터 여러가지 테스트 케이스를 돌려보면서 값을 계산해야 한다. 특히 경계값에서 실수하는 부분이 많으므로 최대값, 최소값은 반드시 테스트 케이스를 만들어서 실험해보아야 한다.

## 피보나치 수 6(백준 11444)

1시간 걸릴줄 알고 룰룰랄라 덤볐다가 거진 6시간은 잡고 있었던 문제

난이도는 골드밖에 안되서 풀이법이 간단했다. 하지만 나 스스로 생각하지 못했던 문제이다.

## 계산식을 행렬로 바꿔

`F(n) = F(n-1) + F(n-2)`를 행렬로 바꿔서 보자.

```mathematica
[Fn+2, Fn+1] = [[1, 1,], [1, 0]] * [Fn+1, Fn]
[Fn+2, Fn+1] = [[1, 1,], [1, 0]]^(n+1) * [F1, F0]
[Fn+1, Fn] = [[1, 1], [1, 0]]^(n) * [F1, F0]
```

이렇게 바꾸면 좋은점은 저 N을 거듭제곱형태로 계산할 수 있다는 것이다. 거듭제곱 형태로 계산할 경우 기존의 `O(n)`을 `O(logN)`으로 바꾸는 마법을 경험할 수 있다. 따라서 이 방법을 통해서 훨씬더 빠르게 문제를 해결할 수 있다. 



```c++
lld fibonacci(lld n){
    // (fn+1, fn) = ((1, 1), (1, 0))^(n-1)(1, 1) 
    matrix identity(2, vector<lld>(2));
    matrix A(2, vector<lld>(2));

    for(int i = 0; i<2; i++){
        identity[i][i] = 1;
    }
    
    A[0][0] = A[0][1] = A[1][0] = 1;

    while(n > 0){
        if(n % 2 == 1){
            identity = identity * A;
        }

        A = A * A;
        n /= 2;
    }

    return (identity[1][0]) % MOD;
}

```



## Matrix Operation

여기서 return 구문에 그냥 로컬 변수를 리텅하는 것을 볼 수 있다. 로컬 변수를 리턴해도 오류가 나지 않는것을 보고 깜짝 놀랐다. 그리고 매트릭스를 사용하는 방법은 이번 문제를 해결하면서 처음 알게된 사실이다.

```c++
matrix operator*(matrix &a, matrix&b){
    // (M, K) * (K, N) = (M, N) 
    int M, N, K;
    M = a.size();
    N = b[0].size();
    K = b.size();

    matrix result(M, vector<lld>(N));
    for(int i=0; i<M; i++)
        for(int j=0; j<N; j++)
            for(int k=0; k<K; k++)
                result[i][j] += mul(a[i][k], b[k][j]);

    return result;
}


```





## 문제

피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.

이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.

n=17일때 까지 피보나치 수를 써보면 다음과 같다.

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597

n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.



## 입력

첫째 줄에 n이 주어진다. n은 1,000,000,000,000,000,000보다 작거나 같은 자연수이다.



## 출력

첫째 줄에 n번째 피보나치 수를 1,000,000,007으로 나눈 나머지를 출력한다.



## 예제

```
1000
```

```
517691607
```
## 히스토그램에서 가장 큰 직사각형 (백준 6549)

이 문제는 대략 8개월만에 풀었다. 오늘은 2시간 30분정도 걸려서 푼것 같다. 막상 풀고 나니 내가 했던 실수들이 정말로 뭐였는지 왜 그렇게 실수를 했는지 원인을 마구마구 찾고 싶다. 그래서 오늘 시간을 더 할애하여 내가 틀렸던 이유에 대해서 자세히 정리하고자 했다.



## Stack을 이용한 풀이

나는 스택을 이용해서 문제를 풀었다. 문제를 풀고나서 다른 사람의 풀이를 보니 다른 사람들은 세그먼트 트리를 이용해서 푸는것 같다. 다른 사람의 코드를 보는 습관을 들이면 좋은 것 같다. 특히 실력자들이 내 놓는 풀이는 정말로 정답지처럼 깔끔하고 공부에 많은 도움이 된다. 우선 내가 생각했던 풀이를 적겠다.



나는 문제를 직관적으로 접근했다. 내가 문제를 보고 손으로 푼다면 어떻게 풀지를 먼저 생각해서 그 풀이법을 찾았다. 내가 생각한 풀이방법은 내가 선택한 도형을 가장 왼쪽으로 해서 직사각형을 그릴경우 어떤 직사각형이 그려질지를 먼저 생각했다. 이렇게 생각하니 그저께 풀었던 스택 문제가 도움이 되었다. Right First Larger Number를 찾는 문제였는데 이 문제도 직관적으로 스택을 이용해서 푸는데 애를 많이 먹었는데 이번 문제를 푸는데 도움을 받았다. 그래서 이 알고리즘은 다음과 같은 로직을 따른다.

```c++
st.push(0); 
for(llu i = 1; i<n; i++){
    while(!st.empty() and height[st.top()] > height[i]){
        llu local_max_val = height[st.top()] * (i - st.top()); 
        left_to_right[st.top()] = local_max_val;
        st.pop();
    }
    st.push(i);
}
```

스택에 height array의 index를 push하고 stack의 top element의 height 보다 작은 것이 온다면 pop 하면서 해당 인덱스의 도형을 가장왼쪽으로 삼았을 때의 직사각형의 최대 넓이를 계산한다. 로직 자체는 간단했으나 실수가 많았다.



## 지금 봐도 아리까리한 실수모음

1. input의 범위 착각 : 인풋이 항상 0보다 큰 정수가 온다고 착각했었다. 그래서 최대 넓이는 인풋의 길이보다는 크겠지라는 생각으로 처음에 주는 인풋의 길이 값을 최대 값을 저장하는 변수의 초기값으로 설정했다. 이것은 인풋에 0이 안온다면 문제가 없지만 오게된다면 당현이 틀린 알고리즘이 된다.
2. unsigned int를 index로 사용시 음수의 값 표현 안됨 : 이건 디버거가 아니면 찾아 낼 수 없었던 오류인거 같다. 누가 이걸 생각할까...진짜 하지 말아야하는 실수이고 코드 짤 때 귀찮더라고 꼭 눈 디버거를 사용해서 loop 을 돌려야하는 가장 큰 이유인거 같다. 
3. 왼쪽만 생각하는 실수 : 나는 도형의 최대 크기가 항상 왼쪽을 기준으로 삶았을 때만 있는줄 알았다. 하지만 이건 내 착각이였더. 오른쪽을 기준으로도 한번더 생각해주어야 문제를 해결할 수 있다. 이걸 생각못하고 있었던 것도 대단하고 다시 찾아서 생각한것도 대단하다.


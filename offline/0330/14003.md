## 백준 14004번 문제

이 문제는 LIS 5번 문제이다.

내가 생각했던 풀이는 틀렸다. 왜 틀렸는지 찾는데에만 무진장 많은 시간을 쏟았다. 하지만 다음에도 비슷한 상황이 생긴다면 조금 더 빠르게 해결 할 수 있을 것이다.

### 틀린 풀이

기본적으로 LIS 2번 문제와 풀이가 유사하다. 다만 원래 LIS 배열 자체를 복원하는것이 문제이다.

이 배열을 복원하기 위해서 나는 추가로 배열을 하나 더 만들어서 인덱스를 저장하게끔 만들어서 해결하려고 했다. 물론 실패했지만...

실패한 원리는 이렇다. s와 e 사이의 값들이 변경되어있다고 가정하고 그 사이의 값들을 순차적으로 s-e개를 선택하면 원래 값이 복원될 줄 알았다. 하지만 이는 오산이였다. 왜냐하면 s와 e 사이에서도 LIS 문제가 발생할 수 있기 때문이다. 나는 이 사실을 엄청나게 큰 랜덤 수열을 만들고 정답 코드의 결과와 비교해가면서 내가 왜 틀렸는지 찾을 수 있었다. 

문제를 틀렸다는 사실을 알게되니깐 뭔가 하나를 배웠다. 바로 내가 이해하지 못한 원리는 맞을 수 없는 코드라는 사실이다. 사실 이 코드를 짜고 맞췄다고 한들 나는 크게 배운게 없을 것이다. 하지만 틀리고 나서야 비로소 내가 생각한 방법이 틀렸다는 것을 확인하고 왜 틀렸는지 확인하는 과정에서 크게 배운 것 같다. 

아래는 틀린 코드이다. 두번째 `while`문 안에서 s, e 사이에서 순차적으로 찾으려고 하는데 이는 잘못된 방법이다. 이유는 LIS가 중첩되어 있을 수 있기 때문이다.  반례는 input.txt에서 찾을 수 있다.

```cpp
int s, e;
s = e = ans.size() - 1;
cout << ans.size() << endl;
while(e!=0){
    if(s!=0 and ans_idx[s-1] > ans_idx[e]) s--;
    else if (s==0 or s < e) { 
        // [s, e)
        // cout << s << " " << e << endl;
        int tmp, x;
        tmp = ans_idx[e];
        while(true){
            // assert(tmp >= 0);
            x = arr[--tmp];
            // cout << tmp << endl;
            if(ans[e] > x and (s==0 or ans[s-1] < x)){
                ans[e-1] = x;
                ans_idx[e-1] = tmp;
                break;
            }
        }
        e--; 
    }
    else {s--; e--;}
}
for(int i=0; i<ans.size(); i++){
    cout << ans[i] << " ";
}
```



### 맞는 풀이